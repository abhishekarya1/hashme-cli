from os import listdir, sep, chdir
from os.path import isfile, join

import re

from datetime import datetime

import hashlib
from pathlib import Path

from constants import MD5, SHA256, UTF8, VERSION


def generate_hash_md5(file):
	md5_hash = hashlib.md5()
	content = open(file, "rb").read()
	md5_hash.update(content)
	md5_digest = md5_hash.hexdigest()
	return md5_digest


def generate_hash_sha256(file):
	sha256_hash = hashlib.sha256()
	content = open(file, "rb").read()
	sha256_hash.update(content)
	sha256_digest = sha256_hash.hexdigest()
	return sha256_digest


def verify_hash(file, algorithm, hash_value):
	if algorithm == MD5:
		if generate_hash_md5(file) == hash_value:
			return "File matches the MD5 hash value provided - VERIFIED."
		else:
			return "File doesn't match the MD5 hash value provided - UNVERIFIED."
	elif algorithm == SHA256:
		if generate_hash_sha256(file) == hash_value:
			return "File matches the SHA256 hash value provided - VERIFIED."
		else:
			return "File doesn't match the SHA256 hash value provided - UNVERIFIED."
	else:
		return "Invalid algorithm specified."


def file_gen(file):
	with open(f"{file}.verifile", 'w', encoding='utf-8') as f:
		md5_hash = generate_hash_md5(file)
		sha256_hash = generate_hash_sha256(file)
		f.write(f"MD5={md5_hash}\nSHA256={sha256_hash}")
	print('Verifile generated successfully.')


def generate_verifile(file):
	if (os.path.splitext(file)[1] == '.verifile'):
		print(
			"Are you sure you want to create verifile for an existing verifile? (y/n):"
		)
		while (True):
			inp = str(input())
			if inp.lower() == 'n':
				print("No verifile generated.")
				break
			elif inp.lower() == 'y':
				file_gen(file)
				break
			else:
				print('Invalid option. Please choose from (y/n):')
				continue
	else:
		file_gen(file)


def verify_file(file):
	with open(f"{file}.verifile", 'r', encoding='utf-8') as f:
		data = f.read().split('\n')
		for i in range(len(data)):
			line = data[i].split('=')
			algo = line[0]
			hash_val = line[1]
			print(f"{verify_hash(file, algo.lower(), hash_val)}")


def generate_folder(path):
	if Path(path).exists():
		chdir(path)
		folderpath = Path('verifolder')
		folderpath.mkdir(
			parents=True,
			exist_ok=True)  #exist_ok will allow overwite if folder already exists

		foldername = str(folderpath.cwd()).split(sep)[-1]  #separating by os.sep (different on Windows and Linux)
		filename = f'verifile.md5'

		filepath = folderpath / filename  #/ behaves differently with path objects

		with filepath.open("w", encoding="utf-8") as f:
			#excludes filenames starting with dot (.)
			file_list = [i for i in listdir(folderpath.cwd()) if isfile(join(folderpath.cwd(), i)) and i[0] != '.']
			f.write(f'; Generated by HASHME {VERSION} on {datetime.now().strftime("%d-%m-%Y")} at {datetime.now().strftime("%H:%M:%S")}\n')
			f.write(f'; Foldername: \"{foldername}\" at creation.\n\n')
			for i in file_list:
				f.write(f'{i} {generate_hash_md5(i)}\n')
	else:
		print("Specified path is invalid.")


def parse_file():
	file_dict = {}
	with open("verifile.md5", "r", encoding="utf-8") as f:
		text = re.sub(';.*', '', f.read()).strip()
		data = text.split('\n')
		for i in range(len(data)):
			line = data[i].split(' ')
			file_dict.update({line[0] : line[1]})
	return file_dict

def verify_folder():
	parent_folder = Path().cwd().parent
	file_list = [i for i in listdir(parent_folder) if isfile(join(parent_folder, i)) and i[0] != '.']
	file_dict = parse_file()
	
	chdir(parent_folder)
	for file in file_dict.keys():
		if isfile(file):
			if generate_hash_md5(file) == file_dict[file]:
				print(f'{file} : OK')
			elif generate_hash_md5(file) != file_dict[file]:
				print(f'{file} : BAD')
		else:
			print(f'{file} : MISSING')